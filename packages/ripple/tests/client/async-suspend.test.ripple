import { flushSync, track } from 'ripple';

describe('async suspense', () => {
	it('hides child content during re-suspension when tracked dependency changes', async () => {
		let resolve_fn: (() => void) | null = null;

		component Child({ count }: { count: any }) {
			await track(() => {
				@count;
				return new Promise<void>((resolve) => {
					resolve_fn = resolve;
				});
			});

			<div class="child-content">{'child content'}</div>
		}

		component App() {
			let count = track(0);

			try {
				<Child {count} />
			} pending {
				<div class="pending">{'pending...'}</div>
			}

			<button onClick={() => @count++}>{'Increment'}</button>
		}

		render(App);

		// Initial state: should show pending
		await new Promise((resolve) => setTimeout(resolve, 0));
		flushSync();
		expect(container.innerHTML).toContain('pending...');
		expect(container.innerHTML).not.toContain('child content');

		// Resolve the first promise
		resolve_fn?.();
		await new Promise((resolve) => setTimeout(resolve, 0));
		flushSync();

		// After resolution: should show child content, not pending
		expect(container.innerHTML).toContain('child content');
		expect(container.innerHTML).not.toContain('pending...');

		// Now trigger re-suspension by changing count
		const button = container.querySelector('button');
		button?.click();
		flushSync();

		// Wait for microtask to process
		await new Promise((resolve) => setTimeout(resolve, 0));
		flushSync();

		// BUG: During re-suspension, we should only see pending, not child content
		// The child content should be hidden when the new promise is pending
		expect(container.innerHTML).toContain('pending...');
		expect(container.innerHTML).not.toContain('child content');
	});

	it('shows pending UI immediately when child suspends', async () => {
		component Child() {
			await new Promise((resolve) => setTimeout(resolve, 50));
			<div class="child">{'loaded'}</div>
		}

		component App() {
			try {
				<Child />
			} pending {
				<div class="pending">{'loading...'}</div>
			}
		}

		render(App);

		// Wait for microtask
		await new Promise((resolve) => setTimeout(resolve, 0));
		flushSync();

		// Should show pending, not child content
		expect(container.innerHTML).toContain('loading...');
		expect(container.innerHTML).not.toContain('loaded');

		// Wait for child to resolve
		await new Promise((resolve) => setTimeout(resolve, 100));
		flushSync();

		// Should show child content, not pending
		expect(container.innerHTML).toContain('loaded');
		expect(container.innerHTML).not.toContain('loading...');
	});
});

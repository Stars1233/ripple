import { bindValue, flushSync, track, TrackedArray } from 'ripple';

describe('try block with catch and pending', () => {
	it('catch block works when component throws before await with pending block', async () => {
		component App() {
			try {
				<ThrowingChild />
			} pending {
				<p>{'loading...'}</p>
			} catch (err) {
				<p>{'caught error'}</p>
			}
		}

		component ThrowingChild() {
			throw new Error('sync error');
			let data = await Promise.resolve('hello');
			<p>{data}</p>
		}

		render(App);

		await new Promise((resolve) => setTimeout(resolve, 0));
		flushSync();

		expect(container.innerHTML).toContain('caught error');
		expect(container.innerHTML).not.toContain('loading...');
	});

	it('catch block works when component throws after await with pending block', async () => {
		component App() {
			try {
				<ThrowingAfterAwait />
			} pending {
				<p>{'loading...'}</p>
			} catch (err) {
				<p>{'caught error'}</p>
			}
		}

		component ThrowingAfterAwait() {
			let data = await Promise.resolve('hello');
			throw new Error('error after await');
			<p>{data}</p>
		}

		render(App);

		await new Promise((resolve) => setTimeout(resolve, 0));
		flushSync();

		expect(container.innerHTML).toContain('caught error');
		expect(container.innerHTML).not.toContain('loading...');
	});

	it('catch block works with try/catch/pending when async body rejects', async () => {
		component App() {
			try {
				let data = await Promise.reject(new Error('rejected'));
				<p>{data}</p>
			} pending {
				<p>{'loading...'}</p>
			} catch (err) {
				<p>{'caught rejection'}</p>
			}
		}

		render(App);

		await new Promise((resolve) => setTimeout(resolve, 0));
		flushSync();

		expect(container.innerHTML).toContain('caught rejection');
		expect(container.innerHTML).not.toContain('loading...');
	});
});

describe('try block', () => {
	it(
		'does not compile ref binds as async callbacks inside try/pending async branches',
		async () => {
			component App() {
				try {
					<Child />
				} pending {
					<p>{'loading...'}</p>
				}
			}

			component Child() {
				let value = track(1);
				await Promise.resolve(@value + 1);

				<input type="number" {ref bindValue(value)} />
			}

			render(App);

			await new Promise((resolve) => setTimeout(resolve, 0));
			flushSync();

			const input = container.querySelector('input') as HTMLInputElement | null;
			expect(input?.value).toBe('1');
			expect(container.innerHTML).not.toContain('loading...');
		},
	);

	it('does not crash when async component is used inside try/pending', async () => {
		component App() {
			try {
				<AsyncChild />
			} pending {
				<p>{'loading...'}</p>
			}
		}

		component AsyncChild() {
			let data = await Promise.resolve(['a', 'b', 'c']);

			<ul>
				for (let item of data) {
					<li>{item}</li>
				}
			</ul>
		}

		render(App);

		await new Promise((resolve) => setTimeout(resolve, 0));
		flushSync();

		const items = container.querySelectorAll('li');
		expect(items.length).toBe(3);
		expect(items[0].textContent).toBe('a');
		expect(items[1].textContent).toBe('b');
		expect(items[2].textContent).toBe('c');
	});

	it(
		'does not crash when async component with tracked state is used inside try/pending',
		async () => {
			component App() {
				let query = track('');

				try {
					<FilteredList {query} />
				} pending {
					<p>{'loading...'}</p>
				}
			}

			component FilteredList({ query }: { query: any }) {
				let items = await Promise.resolve(['apple', 'banana', 'cherry']);
				let list = TrackedArray.from(items);
				let filtered = track(() => list.filter((item: string) => item.includes(@query)));

				<ul>
					for (let item of @filtered) {
						<li>{item}</li>
					}
				</ul>
			}

			render(App);

			await new Promise((resolve) => setTimeout(resolve, 0));
			flushSync();

			const listItems = container.querySelectorAll('li');
			expect(listItems.length).toBe(3);
		},
	);

	it('if test condition does not become async within try/pending', async () => {
		component App() {
			try {
				let items = await Promise.resolve(['apple', 'banana', 'cherry']);

				if (items.includes('not-in-list')) {
					<p>{'not-in-list is in the list!'}</p>
				} else {
					<p>{'not-in-list is not in the list.'}</p>
				}
			} pending {
				<p>{'loading...'}</p>
			}
		}

		render(App);

		await new Promise((resolve) => setTimeout(resolve, 0));
		flushSync();

		expect(container.innerHTML).toContain('not-in-list is not in the list.');
	});
});
